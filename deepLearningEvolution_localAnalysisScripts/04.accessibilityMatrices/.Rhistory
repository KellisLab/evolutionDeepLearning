geom_hline(yintercept=3, linetype="dashed")+geom_vline(xintercept=0) +
geom_vline(xintercept=0.5, linetype="dashed")+
geom_vline(xintercept=-0.5, linetype="dashed") +
scale_color_manual(values = c("NoSignificantChange" = "darkgrey", "UpInModern" = "#E96D4E", "DownInModern" = "#EAC567"))
plot_modern_archaic_boxplot <- function(peak_id, data, modern, archaic) {
# Extract values for the given peak_id
peak_values <- data[peak_id, ]
if (is.null(peak_values)) {
stop("Peak ID not found in data.")
}
# Prepare a data frame for plotting
plot_data <- data.frame(
Value = as.numeric(c(peak_values[modern], peak_values[archaic])),
Group = c(rep("Modern", length(modern)), rep("Archaic", length(archaic)))
)
# Create the plot
p <- ggplot(plot_data, aes(x = Group, y = Value, color = Group, fill=Group)) +
geom_boxplot(outlier.shape = NA) +  # Boxplot without outlier points
geom_jitter(width = 0.2, alpha = 0.7, size = 1.5) +  # Individual data points
theme_classic() +
labs(
title = peak_id,
x = "Group",
y = "Predicted Accessibility"
) +
theme(
legend.position = "none",
axis.text.x = element_text(size = 12),
axis.text.y = element_text(size = 10),
plot.title = element_text(size = 14, face = "bold")
) +
scale_color_manual(values = c("Modern" = "#F4A361", "Archaic" = "#EAC567"))  # Custom colors
return(p)
}
plot_archaic_modern_top_peaks <- function(sorted_results, data, modern, archaic, N = 10) {
# Get the top N peaks
top_peaks <- head(sorted_results$Peak, N)
# Initialize an empty list to store the plots
plot_list <- list()
# Generate a boxplot for each peak and store it in the plot list
for (peak in top_peaks) {
plot_list[[peak]] <- plot_modern_archaic_boxplot(peak, data, modern, archaic)
}
# Arrange the plots in a grid
grid.arrange(grobs = plot_list, ncol = 2) # Adjust ncol to your preference (e.g., 2 columns)
}
sorted_modern_vs_archaic_results <- modernArchaicFullResults[["brain_male_embryo_105_days"]][order(modernArchaicFullResults[["brain_male_embryo_105_days"]]$pAdj), ]
plot_archaic_modern_top_peaks(subset(sorted_modern_vs_archaic_results, log2FC < -0.5), measurement_data, modern, archaic, N = 2)
plot_modern_archaic_boxplot <- function(peak_id, data, modern, archaic) {
# Extract values for the given peak_id
peak_values <- data[peak_id, ]
if (is.null(peak_values)) {
stop("Peak ID not found in data.")
}
# Prepare a data frame for plotting
plot_data <- data.frame(
Value = as.numeric(c(peak_values[modern], peak_values[archaic])),
Group = c(rep("Modern", length(modern)), rep("Archaic", length(archaic)))
)
# Create the plot
p <- ggplot(plot_data, aes(x = Group, y = Value, color = Group, fill=Group)) +
geom_boxplot(outlier.shape = NA) +  # Boxplot without outlier points
geom_jitter(width = 0.2, alpha = 0.7, size = 1.5) +  # Individual data points
theme_classic() +
labs(
title = peak_id,
x = "Group",
y = "Predicted Accessibility"
) +
theme(
legend.position = "none",
axis.text.x = element_text(size = 12),
axis.text.y = element_text(size = 10),
plot.title = element_text(size = 14, face = "bold")
) +
scale_color_manual(values = c("Modern" = "#F4A361", "Archaic" = "#EAC567"))  +
scale_fill_manual(values = c("Modern" = "#F4A361", "Archaic" = "#EAC567"))
return(p)
}
plot_archaic_modern_top_peaks <- function(sorted_results, data, modern, archaic, N = 10) {
# Get the top N peaks
top_peaks <- head(sorted_results$Peak, N)
# Initialize an empty list to store the plots
plot_list <- list()
# Generate a boxplot for each peak and store it in the plot list
for (peak in top_peaks) {
plot_list[[peak]] <- plot_modern_archaic_boxplot(peak, data, modern, archaic)
}
# Arrange the plots in a grid
grid.arrange(grobs = plot_list, ncol = 2) # Adjust ncol to your preference (e.g., 2 columns)
}
sorted_modern_vs_archaic_results <- modernArchaicFullResults[["brain_male_embryo_105_days"]][order(modernArchaicFullResults[["brain_male_embryo_105_days"]]$pAdj), ]
plot_archaic_modern_top_peaks(subset(sorted_modern_vs_archaic_results, log2FC < -0.5), measurement_data, modern, archaic, N = 2)
plot_modern_archaic_boxplot <- function(peak_id, data, modern, archaic) {
# Extract values for the given peak_id
peak_values <- data[peak_id, ]
if (is.null(peak_values)) {
stop("Peak ID not found in data.")
}
# Prepare a data frame for plotting
plot_data <- data.frame(
Value = as.numeric(c(peak_values[modern], peak_values[archaic])),
Group = c(rep("Modern", length(modern)), rep("Archaic", length(archaic)))
)
# Create the plot
p <- ggplot(plot_data, aes(x = Group, y = Value, color = Group, fill=Group)) +
geom_boxplot(outlier.shape = NA, alpha=0.2) +  # Boxplot without outlier points
geom_jitter(width = 0.2, size = 1.5) +  # Individual data points
theme_classic() +
labs(
title = peak_id,
x = "Group",
y = "Predicted Accessibility"
) +
theme(
legend.position = "none",
axis.text.x = element_text(size = 12),
axis.text.y = element_text(size = 10),
plot.title = element_text(size = 14, face = "bold")
) +
scale_color_manual(values = c("Modern" = "#F4A361", "Archaic" = "#EAC567"))  +
scale_fill_manual(values = c("Modern" = "#F4A361", "Archaic" = "#EAC567"))
return(p)
}
plot_archaic_modern_top_peaks <- function(sorted_results, data, modern, archaic, N = 10) {
# Get the top N peaks
top_peaks <- head(sorted_results$Peak, N)
# Initialize an empty list to store the plots
plot_list <- list()
# Generate a boxplot for each peak and store it in the plot list
for (peak in top_peaks) {
plot_list[[peak]] <- plot_modern_archaic_boxplot(peak, data, modern, archaic)
}
# Arrange the plots in a grid
grid.arrange(grobs = plot_list, ncol = 2) # Adjust ncol to your preference (e.g., 2 columns)
}
sorted_modern_vs_archaic_results <- modernArchaicFullResults[["brain_male_embryo_105_days"]][order(modernArchaicFullResults[["brain_male_embryo_105_days"]]$pAdj), ]
plot_archaic_modern_top_peaks(subset(sorted_modern_vs_archaic_results, log2FC < -0.5), measurement_data, modern, archaic, N = 2)
plot_archaic_modern_top_peaks(subset(sorted_modern_vs_archaic_results, log2FC > 0.5), measurement_data, modern, archaic, N = 2)
plot_archaic_modern_top_peaks <- function(sorted_results, data, modern, archaic, N = 2) {
# Get the top N peaks
top_peaks <- head(sorted_results$Peak, N)
# Initialize an empty list to store the plots
plot_list <- list()
# Generate a boxplot for each peak and store it in the plot list
for (peak in top_peaks) {
plot_list[[peak]] <- plot_modern_archaic_boxplot(peak, data, modern, archaic)
}
# Arrange the plots in a grid
grid.arrange(grobs = plot_list, ncol = 1) # Adjust ncol to your preference (e.g., 2 columns)
}
sorted_modern_vs_archaic_results <- modernArchaicFullResults[["brain_male_embryo_105_days"]][order(modernArchaicFullResults[["brain_male_embryo_105_days"]]$pAdj), ]
plot_archaic_modern_top_peaks(subset(sorted_modern_vs_archaic_results, log2FC < -0.5), measurement_data, modern, archaic, N = 2)
plot_archaic_modern_top_peaks(subset(sorted_modern_vs_archaic_results, log2FC > 0.5), measurement_data, modern, archaic, N = 2)
grid.arrange(a,b)
a <- plot_archaic_modern_top_peaks(subset(sorted_modern_vs_archaic_results, log2FC < -0.5), measurement_data, modern, archaic, N = 2)
b <- plot_archaic_modern_top_peaks(subset(sorted_modern_vs_archaic_results, log2FC > 0.5), measurement_data, modern, archaic, N = 2)
grid.arrange(a,b)
grid.arrange(a,b, ncol=2)
pdf("pdf/2C.modernArchaicBrainExamples.pdf", height=5, width=5)
grid.arrange(a,b, ncol=2)
dev.off()
plot_peak_boxplot("chr1.248906125.248907044", data, archaic, modern, greatApe)
p <- plot_peak_boxplot("chr1.248906125.248907044", measurement_data, archaic, modern, greatApe)
p
sorted_results <- homininGreatApeFullResults[["brain_male_embryo_105_days"]][order(results$pAdj), ]
sorted_results <- homininGreatApeFullResults[["brain_male_embryo_105_days"]][order(homininGreatApeFullResults[["brain_male_embryo_105_days"]]$pAdj), ]
sorted_results
head(sorted_results)
plot_top_peaks(subset(sorted_results, log2FC > 0), measurement_data, archaic, modern, greatApe, N = 2)
plot_top_peaks(subset(sorted_results, log2FC < 0), measurement_data, archaic, modern, greatApe, N = 2)
c <- plot_top_peaks(subset(sorted_results, log2FC > 0), measurement_data, archaic, modern, greatApe, N = 2)
d <- plot_top_peaks(subset(sorted_results, log2FC < 0), measurement_data, archaic, modern, greatApe, N = 2)
grid.arrange(c,d,ncol=2)
grid.arrange(c,d,ncol=1)
plot_peak_boxplot <- function(peak_id, data, archaic, modern, greatApe) {
# Combine archaic and modern to form the hominin group
hominin <- c(archaic, modern)
nonhominin <- greatApe
# Extract values for the given peak_id
peak_values <- data[peak_id, ]
if (is.null(peak_values)) {
stop("Peak ID not found in data.")
}
# Prepare a data frame for plotting
plot_data <- data.frame(
Value = as.numeric(c(peak_values[hominin], peak_values[nonhominin])),
Group = c(rep("Hominin", length(hominin)), rep("Non-Hominin", length(nonhominin)))
)
p <-  ggplot(plot_data, aes(x = Group, y = Value, color = Group)) +
geom_boxplot(outlier.shape = NA) +  # Boxplot without outlier points
geom_jitter(width = 0.2, alpha = 0.7, size = 1.5) +  # Individual data points
theme_classic() +
labs(
title = peak_id,
x = "Group",
y = "Predicted Accessibility"
) +
theme(
legend.position = "none",
axis.text.x = element_text(size = 12),
axis.text.y = element_text(size = 10),
plot.title = element_text(size = 14, face = "bold")
) +
scale_color_manual(values = c("Hominin" = "#E96D4E", "Non-Hominin" = "#254857"))  # Custom colors
return(p)
}
grid.arrange(c,d,ncol=1)
plot_peak_boxplot <- function(peak_id, data, archaic, modern, greatApe) {
# Combine archaic and modern to form the hominin group
hominin <- c(archaic, modern)
nonhominin <- greatApe
# Extract values for the given peak_id
peak_values <- data[peak_id, ]
if (is.null(peak_values)) {
stop("Peak ID not found in data.")
}
# Prepare a data frame for plotting
plot_data <- data.frame(
Value = as.numeric(c(peak_values[hominin], peak_values[nonhominin])),
Group = c(rep("Hominin", length(hominin)), rep("Non-Hominin", length(nonhominin)))
)
p <-  ggplot(plot_data, aes(x = Group, y = Value, color = Group, fill=Group)) +
geom_boxplot(outlier.shape = NA, alpha=0.2) +  # Boxplot without outlier points
geom_jitter(width = 0.2, size = 1.5) +  # Individual data points
theme_classic() +
labs(
title = peak_id,
x = "Group",
y = "Predicted Accessibility"
) +
theme(
legend.position = "none",
axis.text.x = element_text(size = 12),
axis.text.y = element_text(size = 10),
plot.title = element_text(size = 14, face = "bold")
) +
scale_color_manual(values = c("Hominin" = "#E96D4E", "Non-Hominin" = "#254857"))  # Custom colors
return(p)
}
c <- plot_top_peaks(subset(sorted_results, log2FC > 0), measurement_data, archaic, modern, greatApe, N = 2)
d <- plot_top_peaks(subset(sorted_results, log2FC < 0), measurement_data, archaic, modern, greatApe, N = 2)
pdf("pdf/2C.homininGreatApeBrainExamples.pdf", height=5, width=5)
grid.arrange(c,d,ncol=1)
dev.off()
ggplot(merged_data, aes(x = log2FC_modern_vs_archaic, y = log2FC_hominin_vs_nonhominin)) +
geom_point(aes(color = Significant_modern_vs_archaic), alpha = 0.7, size = 2) +  # Scatter points
scale_color_manual(values = c("Significant" = "red", "Not Significant" = "black")) +
theme_classic() +
labs(
title = "Comparison of Effect Sizes",
x = "Log2FC (Modern vs Archaic)",
y = "Log2FC (Hominin vs Non-Hominin)"
) +
theme(
plot.title = element_text(size = 14, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
# merging
merged_data <- merge(modern_vs_archaic_results, results, by = "Peak", suffixes = c("_modern_vs_archaic", "_hominin_vs_nonhominin"))
library(ggplot2)
library(ggpubr)
library(pheatmap)
library(dplyr)
library(gridExtra)
# Define haplotype groupings
archaic <- c("altai.Neanderthal.A", "altai.Neanderthal.B",
"chagyrskaya.neanderthal.A", "chagyrskaya.neanderthal.B",
"vindija.neanderthal.A", "vindija.neanderthal.B",
"denisova.A", "denisova.B")
modern <- c("HG00525.A", "HG00525.B",
"HG02615.A", "HG02615.B",
"HG03079.A", "HG03079.B",
"NA18858.A", "NA18858.B",
"NA20517.A", "NA20517.B")
greatApe <- c("clara.panTroTro.A", "clara.panTroTro.B",
"jimmie.panTroVerus.A", "jimmie.panTroVerus.B",
"nakuu.panTroSchweinfurthii.A", "nakuu.panTroSchweinfurthii.B",
"taweh.panTroEllioti.A", "taweh.panTroEllioti.B",
"dian.gorGorGor.A", "dian.gorGorGor.B",
"victoria.gorBeringeiGraueri.A", "victoria.gorBeringeiGraueri.B",
"natalie.panPaniscus.A", "natalie.panPaniscus.B",
"dunja.ponAbe.A", "dunja.ponAbe.B")
hominin <- c(modern, archaic)
shuffle_groups <- function(samples, group_size) {
shuffled_samples <- sample(samples, length(samples), replace = FALSE)
shuffleA <- shuffled_samples[1:group_size]
shuffleB <- shuffled_samples[(group_size + 1):length(shuffled_samples)]
return(list(ShuffleA = shuffleA, ShuffleB = shuffleB))
}
shuffled_groups <- shuffle_groups(c(hominin, greatApe), length(hominin))
# initialize output files and writing function
input_dir <- "rawMatrices"
output_dir <- "divergentPeaks"
dir.create(output_dir, showWarnings = FALSE)
dir.create(file.path(output_dir, "upInHominins"), showWarnings = FALSE)
dir.create(file.path(output_dir, "upInGreatApes"), showWarnings = FALSE)
dir.create(file.path(output_dir, "upInModern"), showWarnings = FALSE)
dir.create(file.path(output_dir, "upInArchaic"), showWarnings = FALSE)
dir.create(file.path(output_dir, "upInGroupAShuffle"), showWarnings = FALSE)
dir.create(file.path(output_dir, "upInGroupBShuffle"), showWarnings = FALSE)
dir.create(file.path(output_dir, "backgroundRegions"), showWarnings = FALSE)
dir.create(file.path(output_dir, "noChangeHomininGreatApe"), showWarnings = FALSE)
dir.create(file.path(ouptut_dir, "noChangeModernArchaic"), showWarnings = FALSE)
output_dir <- "divergentPeaks"
dir.create(output_dir, showWarnings = FALSE)
dir.create(file.path(output_dir, "upInHominins"), showWarnings = FALSE)
dir.create(file.path(output_dir, "upInGreatApes"), showWarnings = FALSE)
dir.create(file.path(output_dir, "upInModern"), showWarnings = FALSE)
dir.create(file.path(output_dir, "upInArchaic"), showWarnings = FALSE)
dir.create(file.path(output_dir, "upInGroupAShuffle"), showWarnings = FALSE)
dir.create(file.path(output_dir, "upInGroupBShuffle"), showWarnings = FALSE)
dir.create(file.path(output_dir, "backgroundRegions"), showWarnings = FALSE)
dir.create(file.path(output_dir, "noChangeHomininGreatApe"), showWarnings = FALSE)
dir.create(file.path(output_dir, "noChangeModernArchaic"), showWarnings = FALSE)
write_bed <- function(df, filename) {
bed <- df %>%
mutate(
start = as.integer(start),
end = as.integer(end)
) %>%
select(chrom, start, end, Name, Score, Strand, Annotation)
write.table(bed, file = filename, quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
}
biosample_files <- list.files(input_dir, pattern = "\\.txt$", full.names = TRUE)
homininGreatApe_summary_df <- data.frame(
Biosample = character(),
BackgroundRegions = integer(),
UpregulatedRegions = integer(),
DownregulatedRegions = integer(),
stringsAsFactors = FALSE
)
shuffle_summary_df <- data.frame(
Biosample = character(),
BackgroundRegions = integer(),
UpregulatedRegions = integer(),
DownregulatedRegions = integer(),
stringsAsFactors = FALSE
)
modernArchaic_summary_df <- data.frame(
Biosample = character(),
BackgroundRegions = integer(),
UpregulatedRegions = integer(),
DownregulatedRegions = integer(),
stringsAsFactors = FALSE
)
homininGreatApeFullResults <- list()
shuffleFullResults <- list()
modernArchaicFullResults <- list()
# differential accessibility analysis
for (file in biosample_files) {
# Read the data
#file <- "rawMatrices/brain_male_embryo_105_days.txt" # read a specific biosample instead
biosample <- gsub("\\.txt$", "", basename(file))
data <- read.csv(file, header = TRUE, sep = "\t")
rownames(data) <- data$X
data <- subset(data, select = -c(X))
data <- data[complete.cases(data), ]
# Initialize results dataframe
homininGreatApe_results <- data.frame(Peak = rownames(data), log2FC = NA, pValue = NA)
# Perform differential accessibility test
for (i in 1:nrow(data)) {
hominin_values <- as.numeric(data[i, hominin])
great_ape_values <- as.numeric(data[i, greatApe])
log2FC <- log2(mean(hominin_values, na.rm = TRUE) / mean(great_ape_values, na.rm = TRUE))
test <- t.test(hominin_values, great_ape_values, exact = FALSE)
homininGreatApe_results$log2FC[i] <- log2FC
homininGreatApe_results$pValue[i] <- test$p.value
}
# Calculate adjusted p-values and add metadata
homininGreatApe_results$pAdj <- p.adjust(homininGreatApe_results$pValue, method = "fdr")
homininGreatApe_results$minusLogPAdj <- -log10(homininGreatApe_results$pAdj)
homininGreatApe_results$Change <- ifelse(
homininGreatApe_results$log2FC > 1 & homininGreatApe_results$minusLogPAdj > 2, "UpInHominins",
ifelse(homininGreatApe_results$log2FC < -1 & homininGreatApe_results$minusLogPAdj > 2, "UpInGreatApes", "NoSignificantChange")
)
# Parse the Peak field into BED fields
homininGreatApe_results <- homininGreatApe_results %>%
mutate(
chrom = sapply(strsplit(Peak, "\\."), `[`, 1),
start = as.numeric(sapply(strsplit(Peak, "\\."), `[`, 2)),
end = as.numeric(sapply(strsplit(Peak, "\\."), `[`, 3)),
Name = log2FC,
Score = 0,
Strand = ".",
Annotation = minusLogPAdj
)
homininGreatApe_results <- subset(homininGreatApe_results, chrom != "chrY")
upResults <- homininGreatApe_results %>%
filter(log2FC > 1 & pAdj < 0.01)
downResults <- homininGreatApe_results %>%
filter(log2FC < -1 & pAdj < 0.01)
noChangeResults <- homininGreatApe_results %>%
filter(pAdj >= 0.01)
write_bed(upResults, file.path(output_dir, "upInHominins", paste0(biosample, ".upInHominins.bed")))
write_bed(downResults, file.path(output_dir, "upInGreatApes", paste0(biosample, ".upInGreatApes.bed")))
write_bed(homininGreatApe_results, file.path(output_dir, "backgroundRegions", paste0(biosample, ".background.bed")))
write_bed(noChangeResults, file.path(output_dir, "noChangeHomininGreatApe", paste0(biosample, ".noChangeHomininGreatApe.bed")))
homininGreatApe_summary_df <- rbind(
homininGreatApe_summary_df,
data.frame(
Biosample = biosample,
BackgroundRegions = nrow(homininGreatApe_results),
UpregulatedRegions = nrow(upResults),
DownregulatedRegions = nrow(downResults),
stringsAsFactors = FALSE
)
)
homininGreatApeFullResults[[biosample]] <- homininGreatApe_results
#### SHUFFLE DA ANALYSIS #####
# Initialize results dataframe
shuffleResults <- data.frame(Peak = rownames(data), log2FC = NA, pValue = NA)
# Perform differential accessibility test
for (i in 1:nrow(data)) {
group_a_values <- as.numeric(data[i, shuffled_groups$ShuffleA])
group_b_values <- as.numeric(data[i, shuffled_groups$ShuffleB])
log2FC <- log2(mean(group_a_values, na.rm = TRUE) / mean(group_b_values, na.rm = TRUE))
test <- t.test(group_a_values, group_b_values, exact = FALSE)
shuffleResults$log2FC[i] <- log2FC
shuffleResults$pValue[i] <- test$p.value
}
# Calculate adjusted p-values and add metadata
shuffleResults$pAdj <- p.adjust(shuffleResults$pValue, method = "fdr")
shuffleResults$minusLogPAdj <- -log10(shuffleResults$pAdj)
shuffleResults$Change <- ifelse(
shuffleResults$log2FC > 1 & shuffleResults$minusLogPAdj > 2, "UpInGroupA",
ifelse(shuffleResults$log2FC < -1 & shuffleResults$minusLogPAdj > 2, "UpInGroupB", "NoSignificantChange")
)
# Parse the Peak field into BED fields
shuffleResults <- shuffleResults %>%
mutate(
chrom = sapply(strsplit(Peak, "\\."), `[`, 1),
start = as.numeric(sapply(strsplit(Peak, "\\."), `[`, 2)),
end = as.numeric(sapply(strsplit(Peak, "\\."), `[`, 3)),
Name = log2FC,
Score = 0,
Strand = ".",
Annotation = minusLogPAdj
)
shuffleResults <- subset(shuffleResults, chrom != "chrY")
upShuffleResults <- shuffleResults %>%
filter(log2FC > 1 & pAdj < 0.01)
downShuffleResults <- shuffleResults %>%
filter(log2FC < 0 & pAdj < 0.01)
write_bed(upShuffleResults, file.path(output_dir, "upInGroupAShuffle", paste0(biosample, ".upInGroupAShuffle.bed")))
write_bed(downShuffleResults, file.path(output_dir, "upInGroupBShuffle", paste0(biosample, ".upInGroupBShuffle.bed")))
shuffle_summary_df <- rbind(
shuffle_summary_df,
data.frame(
Biosample = biosample,
BackgroundRegions = nrow(shuffleResults),
UpregulatedRegions = nrow(upShuffleResults),
DownregulatedRegions = nrow(downShuffleResults),
stringsAsFactors = FALSE
)
)
shuffleFullResults[[biosample]] <- shuffleResults
### Modern Archaic DA Analysis ###
modernArchaicResults <- data.frame(Peak = rownames(data), log2FC = NA, pValue = NA)
for (i in 1:nrow(data)) {
modern_values <- as.numeric(data[i, modern])
archaic_values <- as.numeric(data[i, archaic])
log2FC <- log2(mean(modern_values, na.rm = TRUE) / mean(archaic_values, na.rm = TRUE))
test <- t.test(modern_values, archaic_values, exact = FALSE)
modernArchaicResults$log2FC[i] <- log2FC
modernArchaicResults$pValue[i] <- test$p.value
}
modernArchaicResults$pAdj <- p.adjust(modernArchaicResults$pValue, method = "fdr")
modernArchaicResults$minusLogPAdj <- -log10(modernArchaicResults$pAdj)
modernArchaicResults$Change <- ifelse(
modernArchaicResults$log2FC > 1 & modernArchaicResults$minusLogPAdj > 2, "UpinModern",
ifelse(modernArchaicResults$log2FC < -1 & modernArchaicResults$minusLogPAdj > 2, "UpInArchaic", "NoSignificantChange")
)
modernArchaicResults <- modernArchaicResults %>%
mutate(
chrom = sapply(strsplit(Peak, "\\."), `[`, 1),
start = as.numeric(sapply(strsplit(Peak, "\\."), `[`, 2)),
end = as.numeric(sapply(strsplit(Peak, "\\."), `[`, 3)),
Name = log2FC,
Score = 0,
Strand = ".",
Annotation = minusLogPAdj
)
modernArchaicResults <- subset(modernArchaicResults, chrom != "chrY")
upModernResults <- modernArchaicResults %>%
filter(log2FC > 1 & pAdj < 0.01)
upArchaicResults <- modernArchaicResults %>%
filter(log2FC < -1 & pAdj < 0.01)
noChangeResults <- modernArchaicResults %>%
filter(pAdj >= 0.01)
write_bed(upModernResults, file.path(output_dir, "upInModern", paste0(biosample,".upInModern.bed")))
write_bed(upArchaicResults, file.path(output_dir, "upInArchaic", paste0(biosample,".upInArchaic.bed")))
write_bed(noChangeResults, file.path(output_dir, "noChangeModernArchaic", paste0(biosample, "noChangeModernArchaic.bed")))
modernArchaic_summary_df <- rbind(
modernArchaic_summary_df,
data.frame(
Biosample = biosample,
BackgroundRegions = nrow(modernArchaicResults),
UpregulatedRegions = nrow(upModernResults),
DownregulatedRegions = nrow(upArchaicResults),
stringsAsFactors = FALSE
)
)
modernArchaicFullResults[[biosample]] <- modernArchaicResults
}
homininGreatApeFullResults <- readRDS("divergentPeaks/rds/homininGreatApeFullResults.rds")
homininGreatApeFullResults
head(homininGreatApeFullResults)
head(homininGreatApeFullResults$A172)
unique(homininGreatApeFullResults$A172)
unique(homininGreatApeFullResults$A172$Change)
